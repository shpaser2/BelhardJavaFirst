22-10-19
native говорит, что реализация метода написана не на Java. Например метод pow(a,b) в Math.

Ещё раз напоминание о XOR.
A   B   A^B
0   0   0
0   1   1
1   0   1
1   1   0

Для строк Arrays.sort() лексикографическое сравнение происходит. Т.е. строки посимвольно сравниваются слева направо.

printf("формат для параметров строки", параметры..)
Пример:
String person = "mama";
int number = 3;
System.out.printf("%s мыла %s %d раза", person, "раму", number);
%4d - 4 пробела и затем цифра
%.3s - три символа из строки
%.2f - double со всей целой частью и двумя знаками после запятой

Методы и классы

Пример метода:
модиф.доступа   возвращаемый тип          сигнатура
                                    название    параметры
public static   void                main        (String[] args)

Обычно методы называются глаголом. А переменные - существительные.

Общепринято использовать следующую последовательность описания класса:
константы, поля класса (статические), поля экземпляра, конструкторы, методы публичные, методы приватные.

Click on param in method, Alt + Enter, "Bind constructor parameters to fields."
автоматом this под все параметры.

Alt + Insert - дополнительная менюшка для автосоздания конструкторов и прочего.
this() - для вызова конструктора в другом конструкторе. Всегда, как и super() только в самом начале другого конструктора
этого же класса. this() - выбирает конструктор для вызова по порядку и типу параметров.
Конструктор с названием как у класса без new не вызывается.
Java важен только порядок типов в параметрах конструкторов.
Разные названия переменных одних и тех же типов в одной последовательности не делают разных конструкторов.


24-10-19
Ctrl + O - select method to Override/Implement with automatic code completion

Модификаторы доступа
private                     только внутри класса
default(package-private)    + внутри того же пакета
protected                   + в наследниках(подклассах)
public                      + везде

default и protected крайне редко используются

Модификаторы доступа для полей и методов работают все. А для классов - только default и public.
Модификаторы доступа не разрешены внутри тела метода.
По практике - обычно поля объектов private, изредка protected и default.
Из статического метода не можем обратиться к нестатической переменной.

Классы из другого пакета (другой папки) без импорта нельзя использовать. Независимо от модификатора доступа подключаемого пакета.
Alt + Enter, "Import Class" - и будет автоматически подставлен класс после поиска по всей директории до корневого каталога текущего проекта.
Здесь корневая директория - j18. Плюс здесь подключены библиотеки java core и по ним тоже автопоиск идет.

Класс можно подключать импортировав или явно, без импорта: java.sql.Date dateSql = new java.sql.Date(1);
Без импорта используется, когда нужны два класса с одинаковым названием и оба надо одновременно использовать.
Либо второй можно обернуть в свой класс продублировав методы, но "это так себе метод".

"Обычно внутренние и вложенные классы - признак плохого проектирования."

static - используется в утилитарных классах и полях.
Работу со статическими полями принято производить из-вне - статическими методами. (например статический геттер на статическую переменную)
Конструктор - хоть и статический метод, но из него есть доступ к нестатическим переменным.
Ограничения накладываемые static:
    из static метода не можем обращаться к не static переменным.
В утилитарных классах может быть private конструктор. Например класс Math.

final
    - переменную нельзя изменять после инициализации и она обязана быть инициализирована при объявлении переменной или создании объекта
    - метод нельзя переопределить
final фиксирует адрес памяти за переменной, но не ее значение. Можно изменить например класс внутри final класса.
Примеры final добавить с презентации.

enum переменные - это static final переменные. Посмотреть в презентации.
зачем массив значений енам? если есть Enum.Value.name() Можно ли обращаясь к ячейке массива работать как с Enum.Value.name() ?
    Для foreach можно использовать.
Enum - набор ссылок статических объектов.

Порядок инициализации. (при создании класса)
    1. Статические блок и поля
    2. не-статический блок и поля
    3. конструтор

ДЗ** Сломать конструктор (попробовать прервать его работу без создания объекта, если приватное статик поле уже == 1)
И посмотреть реализацию Singletone шаблона, сравнить с ней.
**Enum.valueOf() посмотреть - параметризированный метод это как?




29-10-19
Ctrl + Alt + T - окружить выделенный вызов метода/строку в try/catch, if/else или что-то ещё.

Множество параметров можно передавать двумя способами:
method(Author[] authors);   //передаем объект массива
method(Author... authors);  //передаем в параметрах список авторов
Author... authors - всегда должна идти последним параметром

Случайные числа.

Получить можно двумя способами:
//Первый - выдает 0..1
double random = Math.random();
System.out.println(random);
//второй вариант. Больше возможностей.
Random randomObject = new Random();
randomObject.nextInt(32);   //как параметр передаем границу, которую никогда не получим. от 0 до 31

Наследование.
Было в дз5 отношение "has-a" Пример: у стола н ножек.
Отношение "is-a" - наследование. Person <- Worker. Рабочий является человеком. А вот человек - не всегда рабочий.
Поля Person доступны из Worker. Есть варианты запрета доступа к полям класса родителя.
public class Person{..}
    //..
public class Worker extends Person{..}
    //..
Ключевое слово super - обращение к ближайшему родителю.
super. - метод/поле родителя
super() - конструктор родителя
В простом случае наследование не множественное. Наследуются поля и методы непосредственного родителя.
Если некий класс наследуется от другого - обязательно в конструкторе наследника вызвать контруктор родителя в самом начале.
!Класс наследника не имеет доступа к полям родителя через super."приватное поле родителя". Потому что это другой класс уже.

public class Worker extends Person...
Person worker2 = new Worker("Ivan", 27, 63.9, 500);
worker2.eat("potato");
System.out.println(worker2.growOld());
worker2.work(); - не сможем выполнить. Переменная worker2 типа Person. work() нет у Person, поэтому Java смотрит на классы выше в поисках метода.
Если метода такого и там нет - не дает скомпилировать.
Можно и нужно преобразовать worker2 в тип Worker и тогда поиск реализации метода начнется с класса Worker.
 ((Worker) worker2).work();



//Есть группа аннотаций с RetentionPolicy.SOURCE - это означает,
//    что это есть только в коде до компиляции и только для справки для разработчика.
//@Override из этой оперы.
//Ctrl + O не то же самое в подстановке полей, что и Alt + Insert с выбором метода toString().



Вопросы:
Как достать поле/метод прародителя из наследника?
