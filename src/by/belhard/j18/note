22-10-19
native говорит, что реализация метода написана не на Java. Например метод pow(a,b) в Math.

Ещё раз напоминание о XOR.
A   B   A^B
0   0   0
0   1   1
1   0   1
1   1   0

Для строк Arrays.sort() лексикографическое сравнение происходит. Т.е. строки посимвольно сравниваются слева направо.

printf("формат для параметров строки", параметры..)
Пример:
String person = "mama";
int number = 3;
System.out.printf("%s мыла %s %d раза", person, "раму", number);
%4d - 4 пробела и затем цифра
%.3s - три символа из строки
%.2f - double со всей целой частью и двумя знаками после запятой

Методы и классы

Пример метода:
модиф.доступа   возвращаемый тип          сигнатура
                                    название    параметры
public static   void                main        (String[] args)

Обычно методы называются глаголом. А переменные - существительные.

Общепринято использовать следующую последовательность описания класса:
константы, поля класса (статические), поля экземпляра, конструкторы, методы публичные, методы приватные.

Click on param in method, Alt + Enter, "Bind constructor parameters to fields."
автоматом this под все параметры.

Alt + Insert - дополнительная менюшка для автосоздания конструкторов и прочего.
this() - для вызова конструктора в другом конструкторе. Всегда, как и super() только в самом начале другого конструктора
этого же класса. this() - выбирает конструктор для вызова по порядку и типу параметров.
Конструктор с названием как у класса без new не вызывается.
Java важен только порядок типов в параметрах конструкторов.
Разные названия переменных одних и тех же типов в одной последовательности не делают разных конструкторов.


24-10-19
Ctrl + O - select method to Override/Implement with automatic code completion

Модификаторы доступа
private                     только внутри класса
default(package-private)    + внутри того же пакета
protected                   + в наследниках(подклассах)
public                      + везде

default и protected крайне редко используются

Модификаторы доступа для полей и методов работают все. А для классов - только default и public.
Модификаторы доступа не разрешены внутри тела метода.
По практике - обычно поля объектов private, изредка protected и default.
Из статического метода не можем обратиться к нестатической переменной.

Классы из другого пакета (другой папки) без импорта нельзя использовать. Независимо от модификатора доступа подключаемого пакета.
Alt + Enter, "Import Class" - и будет автоматически подставлен класс после поиска по всей директории до корневого каталога текущего проекта.
Здесь корневая директория - j18. Плюс здесь подключены библиотеки java core и по ним тоже автопоиск идет.

Класс можно подключать импортировав или явно, без импорта: java.sql.Date dateSql = new java.sql.Date(1);
Без импорта используется, когда нужны два класса с одинаковым названием и оба надо одновременно использовать.
Либо второй можно обернуть в свой класс продублировав методы, но "это так себе метод".

"Обычно внутренние и вложенные классы - признак плохого проектирования."

static - используется в утилитарных классах и полях.
Работу со статическими полями принято производить из-вне - статическими методами. (например статический геттер на статическую переменную)
Конструктор - хоть и статический метод, но из него есть доступ к нестатическим переменным.
Ограничения накладываемые static:
    из static метода не можем обращаться к не static переменным.
В утилитарных классах может быть private конструктор. Например класс Math.

final
    - переменную нельзя изменять после инициализации и она обязана быть инициализирована при объявлении переменной или создании объекта
    - метод нельзя переопределить
final фиксирует адрес памяти за переменной, но не ее значение. Можно изменить например класс внутри final класса.
Примеры final добавить с презентации.

enum переменные - это static final переменные. Посмотреть в презентации.
зачем массив значений енам? если есть Enum.Value.name() Можно ли обращаясь к ячейке массива работать как с Enum.Value.name() ?
    Для foreach можно использовать.
Enum - набор ссылок статических объектов.

Порядок инициализации. (при создании класса)
    1. Статические блок и поля
    2. не-статический блок и поля
    3. конструтор

ДЗ** Сломать конструктор (попробовать прервать его работу без создания объекта, если приватное статик поле уже == 1)
И посмотреть реализацию Singletone шаблона, сравнить с ней.
**Enum.valueOf() посмотреть - параметризированный метод это как?




29-10-19
Ctrl + Alt + T - окружить выделенный вызов метода/строку в try/catch, if/else или что-то ещё.

Множество параметров можно передавать двумя способами:
method(Author[] authors);   //передаем объект массива
method(Author... authors);  //передаем в параметрах список авторов
Author... authors - всегда должна идти последним параметром

Случайные числа.

Получить можно двумя способами:
//Первый - выдает 0..1
double random = Math.random();
System.out.println(random);
//второй вариант. Больше возможностей.
Random randomObject = new Random();
randomObject.nextInt(32);   //как параметр передаем границу, которую никогда не получим. от 0 до 31

Наследование.
Было в дз5 отношение "has-a" Пример: у стола н ножек.
Отношение "is-a" - наследование. Person <- Worker. Рабочий является человеком. А вот человек - не всегда рабочий.
Поля Person доступны из Worker. Есть варианты запрета доступа к полям класса родителя.
public class Person{..}
    //..
public class Worker extends Person{..}
    //..
Ключевое слово super - обращение к ближайшему родителю.
super. - метод/поле родителя
super() - конструктор родителя
В простом случае наследование не множественное. Наследуются поля и методы непосредственного родителя.
Если некий класс наследуется от другого - обязательно в конструкторе наследника вызвать контруктор родителя в самом начале.
!Класс наследника не имеет доступа к полям родителя через super."приватное поле родителя". Потому что это другой класс уже.

public class Worker extends Person...
Person worker2 = new Worker("Ivan", 27, 63.9, 500);
worker2.eat("potato");
System.out.println(worker2.growOld());
worker2.work(); - не сможем выполнить. Переменная worker2 типа Person.
    work() нет у Person, поэтому Java смотрит на классы выше в поисках метода.
    Если метода такого и там нет - не дает скомпилировать.
    Можно и нужно преобразовать worker2 в тип Worker и тогда поиск реализации метода начнется с класса Worker.
 ((Worker) worker2).work();

Тема: методы класса Object, рефлексия.

Рефлексия позволяет получить метод к приватному полю вне объекта с приватным полем.
native у методов Object - реализовано не на java языке программирования.

Сравнение объектов.
System.out.println(person1 == person2);  даст false при ссылках на разные области памяти, на разные объекты.
Нормальная автогенерация метода equals.
    Alt + Insert -> equals and hash code -> выбор по чем проводить сравнение. Галочку в последнем окне лучше снять (по полю класса наследника?).

//Есть группа аннотаций с RetentionPolicy.SOURCE - это означает,
//    что это есть только в коде до компиляции и только для справки для разработчика.
//@Override из этой оперы.
//Ctrl + O не то же самое в подстановке полей, что и Alt + Insert с выбором метода toString().

Вопросы:
Как достать поле/метод родителя из наследника?
eatLikePerson() //из наследника Worker
    super.eatLikePerson();
eatLikePerson() //из наследника Person
    super.eat();
вот пример - как достать метод через одного родителя. Крупные связи, через много объектов резко связывают код, нарушают концепцию малой связанности.



31-10-19
Повтор сравнения объектов и прочего с 6го урока.
Person p = new Worker();
p.method();
до компиляции смотрит есть ли метод в Person. Если есть - компилирует, иначе - нет.
После компиляции смотрит уже начиная с Worker'a и выше по иерархии. Если метод есть в Worker'е, то и используется он же.

Реализация hashCode()
    result = 31 * result + (element == null ? 0 : element.hashCode());
    31 выбрано для наибольшей равномерности распределения хэшкодов. Просто берет хэшкоды полей, домножает на 31
     и складывает к накапливаемому для объекта значению.

Абстрактные классы:
Если есть в используемых классах много общего, то это можно вынести в более абстрактный класс.
Можно сделать класс абстрактным, это запретит создавать его экземпляры. Но от него можно и нужно наследовать новые классы.
Ещё можно исопльзовать абстрактные методы - есть сигнатуры, но нет реализаций у таких методов.
От абстрактных классов можно наследовать ещё абстрактные классы.
                            Person                              abstract
                    Worker              Student                 abstract
FactoryWorker   OfficeWorker    PhysicsDept     MathDept        normal class
AbstractWorker worker = new FactoryWorker("Vasiliy", 25); - создается объект более общего типа для полиморфизма при
 передаче параметром в какой либо (статический) метод.

Проверка объекта на тип.
Оператор instanceof возвращает true или false. Слева переменная, справа класс. Вернет true, если объект того же класса
    или ниже его по иерархии (наследуется от этого класса).

Интерфейс.
Все поля в интерфейсе public константами по умолчанию являются.
А final поля всегда обязаны инициализировать.
Методы интерфейса абстрактны и публичны априори.
Интерфейс - контракт в чистом виде. Обязует иметь реализацию указанных в интерфейсе методов.
Интерфейсы могут наследовать другие интерфейсы через слово implements.
!!!Разница - можно наследоваться от множества интерфейсов, а абстрактный класс - только один в родителях.
    В интерфейсе нельзя в отличие от абстрактного класса заложить изменяемые поля.
Поля интерфейсов используются, например, для хранения много раз исопльзуемых значений,
    которые удобно задавать в одном месте.
Модификатор доступа в интерфейсе всегда public.
//дефолтный метод
default void defaultMethod(String param){
 sout("smth");
}
Редко используемо, потому что нарушает концепцию отсутствия реализации методов в интерфейсе.
В абстрактных классах же нет возможности описывать дефолтные методы. В то же время просто не abstract метод
    в абстрактном классе по сути работает как обычный метод, как дефолтный в интерфейсе.
В случае наследования от двух интерфейсов с одинаковыми дефолтными методами обязаны переопределить метод
    дефолтный и тогда не будет проблем с выбором исполняемого дефолтного метода.
После 8й java были введены приватные методы в интерфейсах (с 11й работает).
    Используется для выноса логики, некоторых действий в дефолтных методах.
    Потому что в интерфейсах private автоматически static.
ДЗ: По интерфейсам дописать код.

Порядок инициализации.
ДЗ: еще раз пройтись по процессу инициализации parent и child классов. Есть в презентации.

Коллекции.
\\обычно по устройству, алгоритмам, отличиям разных реализаций коллекций и map
    очень часто вопросы на джунских собеседованиях.
List - списки.
Set - множества, набор уникальных значений.
Коллекции предназначены для хранения объектов, примитивы хранить только через обертки.
    List                interface
        ArrayList       class
        LinkedList      class
ArrayList - обертка над массивом с методами для удобной работы над ними.
LinkedList - двухсвязный список.
    ArrayList [..] [..] [..] [..]

    new LinkedList<>(); // при создании и записи в переменную - используем ссылку на head linked list'a.
    next связывает head со следующим объектом с одной стороны, prev связывает head с другой стороны.
    Если вставлять значение в середину массива - тогда придется менять значения в множестве других ячеек массива.
    В связанном списке же достаточно поменять ссылки у соседей на нового соседа - гораздо менее ресурсоемко.
    Но LinkedList исходя из этого преимущества используется крайне редко.

    Ещё LinkedList не требует сплошного свободного места для расположения себя. В то время как в ArrayList хранение
        организовано последовательно. И при достаточном количестве памяти но из прерванных хоть байтом кусков
        JVM не сможет записать ArrayList в область памяти.

Set
    HashSet - неупорядоченный
    TreeSet - сет на основе "красночерного дерева". Самобалансируется, сам может сортироваться при команде.

Map (она же словарь)
    HashMap (используется во внутренней реализации HashSet), набор ключ-значение.
    HashTree



Вопросы:
hashcode - int конечен ведь. Что делать с вероятностью совпадения ? как без вероятностей сравнить объекты?
    По идее через equals, только это ресурсозатратнее. Или, например, быстро сравнивают хэшкодом, а затем совпавшие
по хэшкоду объекты сравнивают через equals.
Почему нет отдельного переопределения equals() и hashCode()?
    Потому что они должны давать одинаковый результат.




05-11-19
Исключения.
... - другие наследования
                    Trowable
        Exception                 Error
    Runtime     ...                 ...
...

Error - завершается работа программы.
Exception делятся на проверяемые (checked) на этапе компиляции (сам Exception и его наследники кроме RuntimeException)
RuntimeException - unchecked, выпадают по ходу работы без предварительных проверок при компиляции.
Checked обязаны обрабатывать, unchecked - можем не проверять.

stack - пример на LIFO.
//System.exit(0);       //Case to exit without finally. - на вопрос: Всегда ли выполняется finally блок?
private static final List<FuelType> possibleFuelTypes = Arrays.asList(FuelType.AI92, FuelType.AI98);
    -часто применяемая конструкция постоянного списка из объектов
классы Bus, Car, Sedan, Truck, пакет errorExample недописаны.

ДЗ приблизительное:
Пополнить уровень топлива через автосервис, поменять колеса, проверки (топлива и прочее). Стоянка в виде списка с автомобилями.

Вопрос:
в stack локальные переменные? а если ссылочного типа то только ссылки, никак не объекты?
    Ссылки, примитивного типа, порядок вызова методов.

impl - реализации, implementations

план оставшийся:
потоки ввода-вывода
исключения
stream api, лямбды
многопоточность
SQL
JDBC (10е-11е занятия) - начало выпускного проекта.
*Выпускной проект - интерактивное консольное приложение с базой данных из более двух таблиц (join'ы таблицы).
Будет тест по обязательной части. После 11го-12го занятия.
Опиционально:
класс Optional и generics
xml, Json (преобразование строки в объект)
maven




12-11-19
new ArrayList<>() {  { ... } }
        0         1  2
0 создание коллекции
1 переопределение чего-либо, либо создание анонимного класса где нечто имеющееся будет переопределено.
2 переход в контекст свежесозданного объекта для выполнения метода, предварительной инициализации
т.е. по сути создается анонимный класс, для которого выполняется нечто в скобках 2
и это уходит все влево на использование.
Здесь передается блок нестатический для инициализации объекта коллекции.

Есть метод forEach, который применяет что-то для каждой пары значений в мапе например.
shoppingList.forEach((k,v) -> System.out.printf("%s : %d\n", k, v));
                     ................лямбда выражение.............
Для каждого k и v будет применяться то, что после стрелки.
-> это лямбда оператор.

POJO класс или объект. (playing old java object)
Это объект модель, объект без содержания бизнес логики. Класс нужный для объектной модели и не для чего больше.
Если есть логика, преобразование структур - тогда это уже не POJO.

При итерировании по коллекции удалять просто запрещено.
Для этого используется итератор.
Элементы коллекции можно изменять через методы элементов в коллекции.

Конструкция try with resources не только закрывает ресурсы, но и "флашит" их.
Пример: fWriter.flush()
Принудительно берет зависшие данные в буфере и принудительно пихает в ресурс.

С классом Scanner есть множество связанных неочевидных ошибок. Использовать с проверкой.
Сканер обычно обертка над неким потоком.